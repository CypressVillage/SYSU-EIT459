classdef PolarCoding < handle
% Polar Coding Object (PolarCoding)
%                  
%   Author
%       - Bashar Tahir, btahir@nt.tuwien.ac.at
%         (c) 2018 Institute of Telecommunications, TU Wien.
%         www.nt.tuwien.ac.at 
%  
%   Encoding
%       - Unsystematic encoding.
% 
%   Decoding
%       - Successive Cancellation (SC) based decoder
%          -> SC.
%          -> List-SC.
%          -> CRC-List-SC (CRC aided list decoding).

properties
    NrCodeBlocks         % Number of code blocks
    codeRate             % Code rate
    CodedBitsLength      % Total length of coded bits at the encoder output
    RateMatching         % The Rate Matching object
    BaseCodeRate = 1/3;  % Base code rate of the this coding scheme
    DecodingAlgorithm    % The Decoding Algorithm
    ListSize             % List Size for List-SC based decoding
    PolarCodeCRC
end

% Class specific properties
properties (SetAccess = private, Hidden = false)
end
 
methods
%%
    function obj = PolarCoding(varargin)
    % Constructs a new PolarCoding object
         if numel(varargin) == 2
              obj.NrCodeBlocks = varargin{1}.NrCodeBlocks;
              obj.codeRate = varargin{1}.codeRate;
              obj.CodedBitsLength = varargin{1}.CodedBitsLength;
              obj.RateMatching = varargin{1}.RateMatching;
              obj.DecodingAlgorithm = varargin{1}.DecodingAlgorithm;
              obj.ListSize = varargin{1}.ListSize;
              obj.PolarCodeCRC = varargin{2};
          else
              error('Number of input variables must be 1');
          end
    end
%%
    function CodedBitsBlock = Encode(varargin)
        % Polar encode the input bits block
        % Uses the Frozen Set generated by the ConstructPolarCode() function.
        %
        % CodedBits = PolarCoding.Encode(Input bits)
        obj = varargin{1};
        BlockBits = varargin{2};
        Block = varargin{3};

        % Unsystematic Encoding
        n = Block.Power2Size;
        FrozenSet = Block.FrozenSet;
        u = zeros (1, n);
        Kcount = 1;
        for ii = 1:Block.Power2Size
            if FrozenSet(ii) == 0
                u(ii) = BlockBits(Kcount);
                Kcount = Kcount + 1;
            else
                u(ii) = 0;
            end
        end  
        %Kcount  - 1
        v = mod(u*Block.KroneckerMatrix, 2);

        % Apply Rate-Matching
        CodedBitsBlock = obj.RateMatching.RateMatch('Polar', v, 0, 0, Block);           
    end
 %%   
    function DecodedBlockBits = Decode(varargin)
        % Polar decode the input Log-Likelihood Ratios (LLRs) block using the specified Decoding Algorithm
        % Apply the specified Decoding Algorithm and decode each block. 
        % After each block is decoded, CRC is performed and the error
        % detection result is stored in the corresponding Block class.
        %
        % DecodedBits = PolarCoding.Decode(Channel LLRs)
        obj = varargin{1};  
        Block = varargin{3}; 
        INF = 99999999;
        RateDematchedLLRs = obj.RateMatching.RateDematch(varargin{2}, Block);
        DecodedBlockBits = obj.PolarDecode([RateDematchedLLRs  (INF + 100*randn(1,Block.Power2Size-Block.CodedBlockSize))], Block);   
       
        % Subblock CRC calculation
        if obj.NrCodeBlocks  ~= 1
            Block.CRCDetectionResult = Coding.ChannelCodingComponents.CRC.Detect(DecodedBlockBits, '24B');
            DecodedBlockBits = DecodedBlockBits(1:Block.InputBlockSize-24);
        else
            DecodedBlockBits = DecodedBlockBits(1:Block.InputBlockSize);
        end 
        
    end
 %%
    function out = PolarDecode(varargin)
    % Performs the Successive Cancellation (SC) decoding
    % 
    % out = PolarDecode(Dematched LLRs, Current block)
        obj = varargin{1};
        channelLLRs = varargin{2};
        Block = varargin{3};
        FrozenSet = Block.FrozenSet;   
        n = length(channelLLRs);
        out = zeros(1,n);
   
        switch obj.DecodingAlgorithm
            case 'SC'   
                 DecodedBits = Coding.ChannelCodingComponents.polarDecodeMEX(channelLLRs, FrozenSet, Block.Power2Size, 1);  
            case 'List-SC'
                ListSz = obj.ListSize;   
                DecodedBitsL = Coding.ChannelCodingComponents.polarDecodeMEX(channelLLRs, FrozenSet, Block.Power2Size, ListSz);  
                minPM = Inf;
                for L = 1:ListSz
                    if DecodedBitsL(1, L) < minPM
                        minPM = DecodedBitsL(1, L);
                        minL = L;
                    end
                end
                if ListSz == 1
                    DecodedBits = DecodedBitsL;
                else
                    DecodedBits = DecodedBitsL(2:end, minL);
                end
            case 'CRC-List-SC'
                ListSz = obj.ListSize;  
                DecodedBitsL = Coding.ChannelCodingComponents.polarDecodeMEX(channelLLRs, FrozenSet, Block.Power2Size, ListSz);    
                minPM = Inf;
                
                for L = 1:ListSz
                    temp = DecodedBitsL(2:end, L);
                    temp = temp(FrozenSet == 0);
                    res = Coding.ChannelCodingComponents.CRC.Detect(temp.', obj.PolarCodeCRC);
                    if res == 0
                        minL = L;
                        break;
                    end
                end
                
                if res == 1
                    for L = 1:ListSz
                        if DecodedBitsL(1, L) < minPM
                            minPM = DecodedBitsL(1, L);
                            minL = L;
                        end
                    end
                end
                if ListSz == 1
                    DecodedBits = DecodedBitsL;
                else
                    DecodedBits = DecodedBitsL(2:end, minL);
                end
            otherwise
                error('The decoding algorithm is not supported.');
        end
        Kcount = 1;
        for ii = 1:n
            if FrozenSet(ii) == 0
                out(Kcount) = DecodedBits(ii);
                Kcount = Kcount + 1;
            end
        end
    end
end

methods(Static)
    function ConstructPolarCode(varargin)
        % Construct a new Polar code.
        
        obj = varargin{1};
        
        % Automatically select TargetSNR based on prior simulations
        [~, ed] = min(abs(obj.codeRate - [1/6,1/3,1/2,2/3,5/6]).^2);
        switch ed
            case 1
                TargetSNR = -4;
            case 2
                TargetSNR = 1.5;
            case 3
                TargetSNR = 3.25;
            case 4
                TargetSNR = 5.25;
            case 5
                TargetSNR = 7.5;
        end
        % Custom TargetSNR
        % TargetSNR = ?
        for CBi = 1:obj.NrCodeBlocks
            Block = obj.Blocks(CBi);
            k = Block.InputBlockSize;
            Block.CodedBlockSize = ceil(k/obj.codeRate);
            % Code rate selection
            n = 2^nextpow2(k/obj.codeRate);      
            nt = Block.CodedBlockSize;
            Block.Power2Size = n;
            Block.FrozenSet = ConstructPolarCodeAlgo();  

            if n > 512
                Block.KroneckerMatrix = eval(strcat('obj.F',num2str(n)));
            else
                F = [1 0;1 1];
                Fd = [1 0;1 1];
                for np = 1:log2(n)-1
                    F = kron(Fd,F);
                end
                Block.KroneckerMatrix = F;
            end
        end   

        function FrozenSet = ConstructPolarCodeAlgo()
            % Find the frozen set according to http://ieeexplore.ieee.org/document/7998250/ .
            log2n = log2(n);
            P = zeros(n, 1);
            SNR = 10^(TargetSNR/10);
            P(1) = qfunc(sqrt(SNR));
            for i = 1:log2n
                j = 2^(i-1);
                for kz = 0:j-1
                    p = P(kz+1);
                    P(kz+1) = 2*p*(1-p);
                    P(kz+j+1) = qfunc(sqrt(2)*qfuncinv(p));
                end
            end
            P = bitrevorder(P);
            P(nt+1:end) = 1;
            [~,I] = sort(P,'descend');

            FrozenSet = zeros(1,n);
            FrozenSet(I(1:(n-k))) = 1; 
        end  
end
      
end

end

